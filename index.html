<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <meta name="color-scheme" content="dark light">
  <title>Bro · 科幻友情问答</title>
  <meta name="description" content="科幻风格 · 未来科技感 · 兄弟友情问答 · 移动端稳定运行" />
  <!-- 字体（GitHub Pages 可直连） -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700&family=Inter:wght@400;600;700&family=Monoton&family=Black+Ops+One&display=swap" rel="stylesheet">
  <style>
    :root { --bg:#05060a; --card:#0b0f1a; --muted:#93a4c4; --fg:#e6f0ff; --acc:#00e0ff; --acc2:#7b61ff; --danger:#ff3b3b; --ok:#00ffa6; --shadow: 0 10px 30px rgba(0, 224, 255, .25), 0 0 40px rgba(123,97,255,.15); --radius: 18px; }
    * { box-sizing: border-box; }
    html,body{ height:100%; }
    body{ margin:0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, PingFang SC, Microsoft YaHei, Noto Sans CJK SC, sans-serif; color:var(--fg); background:var(--bg); overflow:hidden; }
    /* 科幻动态背景 */
    .bg{ position: fixed; inset: 0; pointer-events:none; z-index:0; overflow:hidden; background:
        radial-gradient(1200px 600px at 80% -10%, rgba(0,224,255,.15), transparent 60%),
        radial-gradient(900px 500px at 10% 110%, rgba(123,97,255,.18), transparent 60%),
        linear-gradient(180deg, #05060a, #05060a 35%, #070a12 100%); }
    .stars, .grid { position:absolute; inset:0; }
    .stars::before, .stars::after{ content:""; position:absolute; inset:-50% -50% -50% -50%; opacity:.25; background: radial-gradient(2px 2px at 20% 30%, #c9e7ff 60%, transparent 61%), radial-gradient(1.5px 1.5px at 70% 60%, #9fd7ff 60%, transparent 61%), radial-gradient(1.2px 1.2px at 40% 80%, #ffffff 60%, transparent 61%), radial-gradient(1.8px 1.8px at 85% 20%, #a9f 60%, transparent 61%); animation: drift 60s linear infinite; }
    .stars::after{ animation-duration: 90s; opacity:.18; filter:blur(.3px); }
    @keyframes drift { from{ transform:translateY(0)} to{ transform:translateY(10%) } }
    .grid::before{ content:""; position:absolute; inset:-10% -10% 0 -10%; background-image: linear-gradient(rgba(0,224,255,.12) 1px, transparent 1px), linear-gradient(90deg, rgba(123,97,255,.12) 1px, transparent 1px); background-size: 80px 80px, 80px 80px; transform: perspective(900px) rotateX(65deg) translateY(10%); filter: drop-shadow(0 0 12px rgba(0,224,255,.12)); animation: gridMove 12s linear infinite; }
    @keyframes gridMove{ from{ background-position:0 0,0 0 } to{ background-position:0 80px,80px 0 } }

    /* 容器 */
    .wrap{ position: relative; z-index:1; height:100dvh; display:grid; place-items:center; padding:24px; }
    .card{ width:min(720px, 96vw); background:linear-gradient(180deg, rgba(12,16,28,.9), rgba(6,10,20,.86)); border:1px solid rgba(123,97,255,.25); border-radius: var(--radius); box-shadow: var(--shadow); overflow:hidden; backdrop-filter: blur(10px); }
    .head{ display:flex; align-items:center; gap:14px; padding:16px 18px; border-bottom:1px solid rgba(255,255,255,.06); background:linear-gradient(90deg, rgba(0,224,255,.12), rgba(123,97,255,.12)); }
    .brand { display:flex; align-items:center; gap:12px; font-family: Orbitron, Inter, sans-serif; letter-spacing:.6px; font-weight:700; text-transform: uppercase; font-size: 14px; color:#cfe9ff; }
    .brand svg{ width:28px; height:28px; filter: drop-shadow(0 2px 10px rgba(0,224,255,.5)); }

    .body{ padding: 20px clamp(16px, 3vw, 28px) 24px; }
    .title{ font-family: Orbitron, Inter, sans-serif; font-size: clamp(20px, 3.2vw, 28px); line-height:1.28; margin:0 0 10px; background: linear-gradient(180deg, #e6f6ff, #aeddff); -webkit-background-clip:text; background-clip:text; color:transparent; text-shadow: 0 6px 24px rgba(0,224,255,.2); }
    .subtitle{ color:var(--muted); font-size: 14px; margin: 0 0 20px; }

    .panel{ display:grid; gap:16px; }
    .choices{ display:grid; grid-template-columns:1fr 1fr; gap:12px; }
    @media (max-width: 520px){ .choices{ grid-template-columns:1fr; } }

    .btn{ --glow: rgba(0,224,255,.55); appearance:none; border:none; outline:none; cursor:pointer; font: 600 16px/1 Inter, system-ui, sans-serif; color:#04121a; padding: 14px 18px; border-radius: 14px; letter-spacing:.2px; background: radial-gradient(120% 180% at 0% 0%, rgba(255,255,255,.7), rgba(255,255,255,.35)), linear-gradient(180deg, var(--acc), var(--acc2)); box-shadow: 0 8px 20px var(--glow), inset 0 -2px 0 rgba(0,0,0,.2); transform: translateZ(0); transition: transform .12s ease, box-shadow .12s ease, filter .12s ease; user-select:none; -webkit-tap-highlight-color: transparent; }
    .btn:active{ transform: translateY(1px); box-shadow: 0 6px 14px var(--glow); }
    .btn.outline{ color:#d5eaff; background: linear-gradient(180deg, rgba(9,14,25,.8), rgba(5,10,20,.8)); border:1px solid rgba(0,224,255,.45); box-shadow: inset 0 0 0 1px rgba(123,97,255,.25), 0 8px 20px rgba(0,0,0,.25); }
    .btn.danger{ background: linear-gradient(180deg, #ff7b7b, #ff3b3b); --glow: rgba(255,59,59,.45); color:#2a0000; }
    .btn.ok{ background: linear-gradient(180deg, #7bffd6, #00ffa6); --glow: rgba(0,255,166,.4); color:#00281c; }

    .footer{ display:none; }

    /* 过场动画 */
    .fade-enter{ opacity:0; transform: translateY(6px) scale(.99); filter: blur(.8px); }
    .fade-active{ transition: all .28s ease; opacity:1; transform: none; filter:none; }

    /* 结果大字 */
    .ending{ padding: 10px 0 6px; font-weight:700; font-size: clamp(22px, 4.5vw, 36px); line-height:1.25; text-align:center; background: linear-gradient(180deg, #fff 20%, #b6eaff 80%); -webkit-background-clip:text; color:transparent; text-shadow: 0 8px 32px rgba(0,224,255,.25); }
    .ending small{ display:block; margin-top:8px; font-weight:500; font-size: 14px; color: var(--muted); }

    /* ===== 恐怖结局 & 艺术字体样式（更恐怖） ===== */
    body.horror-mode .bg{ background:
      radial-gradient(1000px 500px at 50% -10%, rgba(255,0,54,.28), transparent 60%),
      radial-gradient(800px 480px at 0% 110%, rgba(255,0,0,.28), transparent 60%),
      linear-gradient(180deg,#070306,#0a0203); }
    body.horror-mode .card{ border-color: rgba(255,0,54,.7); box-shadow: 0 14px 44px rgba(255,0,54,.4), 0 0 60px rgba(255,0,0,.28); animation: hshake .55s cubic-bezier(.2,.9,.3,1.2) 1; }
    @keyframes hshake{ 0%{transform:translateX(0)} 15%{transform:translateX(-3px)} 35%{transform:translateX(3px)} 55%{transform:translateX(-2px)} 75%{transform:translateX(2px)} 100%{transform:translateX(0)} }
    body.horror-mode::after{ content:""; position:fixed; inset:0; pointer-events:none; z-index:4; background:
      radial-gradient(ellipse at center, rgba(0,0,0,0) 35%, rgba(0,0,0,.5) 90%),
      repeating-linear-gradient(0deg, rgba(255,0,30,.12) 0 2px, rgba(0,0,0,0) 2px 4px);
      animation: flick 0.9s steps(2,end) infinite, pulse 1.8s ease-in-out infinite; mix-blend-mode:multiply; }
    @keyframes pulse{ 0%,100%{opacity:.85} 50%{opacity:1} }
    @keyframes flick{ 0%,100%{filter:contrast(1) hue-rotate(0)} 50%{filter:contrast(1.1) hue-rotate(-12deg) brightness(1.08)} }
    .glitch{ position:relative; text-transform:uppercase; letter-spacing:.5px; filter: drop-shadow(0 0 18px rgba(255,0,40,.45)); animation: heartbeat 2.1s ease-in-out infinite; }
    @keyframes heartbeat{ 0%, 100% { transform: scale(1)} 10% { transform: scale(1.04)} 20% { transform: scale(1)} 30% { transform: scale(1.06)} 40% { transform: scale(1)} }
    .glitch::before, .glitch::after{ content: attr(data-text); position:absolute; left:0; right:0; top:0; opacity:.95; mix-blend-mode:screen; }
    .glitch::before{ color:#ff2a2a; transform:translate(1.5px,0); animation:gl1 .9s infinite linear alternate-reverse; }
    .glitch::after{ color:#00e0ff; transform:translate(-1.5px,0); animation:gl2 .85s infinite linear alternate; }
    @keyframes gl1{ 0%{clip-path: inset(0 0 80% 0)} 50%{clip-path: inset(20% 0 40% 0)} 100%{clip-path: inset(60% 0 0 0)} }
    @keyframes gl2{ 0%{clip-path: inset(60% 0 0 0)} 50%{clip-path: inset(20% 0 40% 0)} 100%{clip-path: inset(0 0 80% 0)} }

    .score{ display:inline-block; margin-top:10px; padding:8px 12px; border-radius:999px; border:1px solid rgba(255,255,255,.2); background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02)); font-weight:700; }
    .art100{ font-family: Monoton, 'Black Ops One', Orbitron, sans-serif; font-size: clamp(28px, 8vw, 72px); line-height:1.05; letter-spacing:1px; text-align:center; background:linear-gradient(180deg,#fff,#a1e4ff 60%,#7b61ff); -webkit-background-clip:text; color:transparent; text-shadow: 0 12px 40px rgba(0,224,255,.35), 0 0 120px rgba(123,97,255,.38);}  
    .only-btn{ display:grid; gap:14px; justify-items:center; }
    .no-select{ -webkit-user-select:none; user-select:none; }

    /* 粒子礼花 & 特效层 */
    #confetti, #fx{ position:fixed; inset:0; pointer-events:none; z-index:3; }

    /* 过场等待 */
    .interlude{ display:grid; gap:14px; justify-items:center; padding:16px 0; }
    .loader{ width:42px; height:42px; border-radius:50%; border:3px solid rgba(255,255,255,.18); border-top-color: #aee9ff; animation: spin 1s linear infinite; filter: drop-shadow(0 0 10px rgba(0,224,255,.25)); }
    @keyframes spin{ to{ transform: rotate(360deg) } }
    .bar{ width: 100%; height:6px; border-radius:999px; background:rgba(255,255,255,.08); overflow:hidden; box-shadow: inset 0 0 0 1px rgba(255,255,255,.06); }
    .bar>i{ display:block; width:0%; height:100%; background: linear-gradient(90deg, var(--acc), var(--acc2)); animation: grow var(--t,1200ms) ease-out forwards; }
    @keyframes grow{ from{ width:0% } to{ width:100% } }
    .il-text{ color:#bfeaff; font-size:13px; opacity:.9; letter-spacing:.3px; }

    /* 双重确认（恐怖风） */
    .confirm-box{ display:grid; gap:14px; justify-items:center; text-align:center; padding:8px 0 10px; }
    .confirm-title{ font-weight:800; font-size: clamp(18px, 3.6vw, 24px); letter-spacing:.5px; }
    .confirm-sub{ color:#ffb7b7; font-size:13px; opacity:.9; }

    /* 减少动画（系统偏好） */
    @media (prefers-reduced-motion: reduce){ .fade-active{ transition:none } .stars::before, .stars::after, .grid::before{ animation:none } body.horror-mode::after{ animation:none } .loader{ animation:none } .bar>i{ animation:none; width:100% } }
      /* ===== 全屏动画模式 ===== */
    body.fx-full .card{ background: transparent; border-color: transparent; box-shadow: none; }
    body.fx-full .head, body.fx-full .body{ opacity:.08; transition: opacity .3s ease; }
    body.fx-full .title{ text-shadow:none; }
    #confetti, #fx, .bg{ will-change: transform, opacity; }
  </style>
</head>
<body>
  <canvas id="confetti" aria-hidden="true"></canvas>
  <canvas id="fx" aria-hidden="true"></canvas>
  <div class="bg" aria-hidden="true">
    <div class="stars"></div>
    <div class="grid"></div>
  </div>
  <main class="wrap">
    <section class="card" role="dialog" aria-modal="true" aria-labelledby="title">
      <header class="head">
        <div class="brand" aria-label="友情勋章">
          <svg viewBox="0 0 64 64" aria-hidden="true">
            <defs><linearGradient id="g1" x1="0" y1="0" x2="1" y2="1"><stop offset="0" stop-color="#00e0ff"/><stop offset="1" stop-color="#7b61ff"/></linearGradient></defs>
          <path d="M28 22c3-6 9-6 12-2l3 4 4-1c6 0 9 10 1 13l-7 3-3 5c-2 3-7 3-9-1l-2-4-5 1c-6 1-10-7-5-12l3-3 8-3z" fill="url(#g1)" opacity=".95"/>
          <path d="M17 28l5-2m4-2l4-1m8 0l4 1m4 2l3 2" stroke="#bfeaff" stroke-width="1.6" stroke-linecap="round" opacity=".85"/>
          </svg>
          <span>Brotherhood Protocol</span>
        </div>
      </header>
      <div class="body">
        <h1 id="title" class="title no-select">我的 bro，你准备好了吗？</h1>
        <p class="subtitle no-select"><strong>只有一次机会，请你认真思考！</strong></p>
        <div id="panel" class="panel"></div>
      </div>
      <div class="footer" aria-hidden="true"></div>
    </section>
  </main>

  <script>
    // ===== Fix: provide a safe shim so any unexpected calls won't crash =====
    if (typeof window.invoke === 'undefined') {
      window.invoke = function(...args){
        console.warn('[shim] window.invoke() was called but no implementation is provided. Args:', args);
        return null;
      };
    }

    const panel = document.getElementById('panel');
    const confettiCanvas = document.getElementById('confetti');
    const fxCanvas = document.getElementById('fx');
    function setFullFX(on){ document.body.classList.toggle('fx-full', !!on); }

    let lock = false; let score = 0;

    const failureQuotes = {
      1:['第1关折戟，兄弟之路还没开始就结束了。','你没把我当兄弟，我却记住了这一天。','友情校验失败：真诚连接未建立。','起点就拐弯，终点也就不必等。','你后退一步，我便退无可退。'],
      2:['爱情与友情的天平偏了，水下的手终究没握住。','你救她没错，但我们也到此为止了。','友情断链：紧急脱离程序已执行。','你选择了她，我选择了沉默。','水面平静，心底已生分岔口。'],
      3:['24小时的陪伴太重？原来我们的故事只到这里。','我会学会独行，你也别回头。','守护协议未签署：照护权限拒绝。','不怪你，只怪承诺太轻。','我把孤独签收，你把承诺退回。'],
      4:['界限与欲望的答卷，只换来一句冷风。','玩笑开到尽头，友情不再发光。','尊重与默契失联：链接中断。','话开过了头，心就找不到位置了。','我收回笑场，你收回轻狂。']
    };
    function pick(arr){ return arr[Math.floor(Math.random()*arr.length)] }

    function guard(fn){ return (...args)=>{ if(lock) return; lock = true; try{ requestAnimationFrame(()=>{ fn(...args); setTimeout(()=>lock=false, 260); }); }catch(e){ lock=false; console.error(e); } }; }

    function mount(el){ el.classList.add('fade-enter'); panel.replaceChildren(el); requestAnimationFrame(()=> el.classList.add('fade-active')); }
    function mk(tag, props={}, ...children){ const el=document.createElement(tag); Object.assign(el, props); for(const c of children){ if(c==null) continue; el.append(c.nodeType? c : document.createTextNode(c)); } return el; }
    function btn(label, cls, handler){ const b=mk('button',{className:`btn ${cls||''}`,type:'button'},label); b.addEventListener('click', guard(handler), {passive:true}); return b; }
    function choiceButtons(opts){ const wrap=mk('div',{className:'choices'}); for(const o of opts){ wrap.append(btn(o.label,o.type||'',o.onClick)); } return wrap; }

    // ===== 过场等待：统一封装 =====
    function interlude(next, text){ const ms = 900 + Math.floor(Math.random()*700); const box = mk('div', {className:'panel interlude'}); const t = mk('div', {className:'il-text'}, text || '链接兄弟协议中…'); const spin = mk('div', {className:'loader'}); const bar = mk('div', {className:'bar'}); const fill = mk('i'); fill.style.setProperty('--t', ms+'ms'); bar.append(fill); box.append(spin, bar, t); mount(box); setTimeout(()=>{ next(); }, ms); }

    // ===== 音效 =====
    let audioCtx; function getCtx(){ if(!audioCtx){ try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){} } return audioCtx }
    function playHorrorFX(){ const ctx=getCtx(); const reduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches; try{ navigator.vibrate && navigator.vibrate([140,60,140,60,100]); }catch(_){} if(!ctx || reduce) return; const t0=ctx.currentTime, dur=.5; // 噪声
      const buffer=ctx.createBuffer(1, ctx.sampleRate*dur, ctx.sampleRate); const data=buffer.getChannelData(0); for(let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1) * (1 - i/data.length); } const noise=ctx.createBufferSource(); noise.buffer=buffer; const filt=ctx.createBiquadFilter(); filt.type='bandpass'; filt.frequency.value=850; filt.Q.value=0.8; const g=ctx.createGain(); g.gain.setValueAtTime(0.4,t0); g.gain.exponentialRampToValueAtTime(0.01,t0+dur); noise.connect(filt).connect(g).connect(ctx.destination); noise.start(); noise.stop(t0+dur); // 低频
      const osc=ctx.createOscillator(); osc.type='sawtooth'; osc.frequency.setValueAtTime(100,t0); osc.frequency.exponentialRampToValueAtTime(45,t0+dur); const g2=ctx.createGain(); g2.gain.setValueAtTime(0.24,t0); g2.gain.exponentialRampToValueAtTime(0.01,t0+dur); osc.connect(g2).connect(ctx.destination); osc.start(); osc.stop(t0+dur); }
    function playWinFX(){ const ctx=getCtx(); if(!ctx) return; const t0=ctx.currentTime; const o1=ctx.createOscillator(); const g1=ctx.createGain(); o1.type='sine'; o1.frequency.setValueAtTime(880,t0); o1.frequency.exponentialRampToValueAtTime(1320,t0+.25); g1.gain.setValueAtTime(0.0001,t0); g1.gain.exponentialRampToValueAtTime(0.25,t0+.02); g1.gain.exponentialRampToValueAtTime(0.0001,t0+.45); o1.connect(g1).connect(ctx.destination); o1.start(); o1.stop(t0+.5); try{ navigator.vibrate && navigator.vibrate([40,20,40]); }catch(_){} }

    // ===== 画布工具（通用） =====
    function setupCanvas(c){ const ctx=c.getContext('2d'); const DPR=Math.max(1, Math.min(2, window.devicePixelRatio||1)); function resize(){ const bb=c.getBoundingClientRect(); c.width=Math.floor(bb.width*DPR); c.height=Math.floor(bb.height*DPR); ctx.setTransform(DPR,0,0,DPR,0,0);} window.addEventListener('resize',resize); resize(); return {ctx}; }
    const conf = (()=>{ const {ctx} = setupCanvas(confettiCanvas); let parts=[], rafId=null, t0=0; function launch(bursts=3){ parts=[]; const W=confettiCanvas.width, H=confettiCanvas.height; for(let b=0;b<bursts;b++){ const cx = (W/(window.devicePixelRatio||1))/2 + (Math.random()-0.5)*120; const cy = (H/(window.devicePixelRatio||1))*0.35 + (Math.random()-0.5)*60; const N = 120; for(let i=0;i<N;i++){ const ang = Math.random()*Math.PI*2; const spd = 2+Math.random()*5; const shape = Math.random()<0.33?'rect':(Math.random()<0.5?'circle':'star'); parts.push({ x:cx, y:cy, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd-3, g:0.09+Math.random()*0.07, s:2+Math.random()*3, a:1, r:Math.random()*Math.PI, rot:(Math.random()-0.5)*0.25, shape }); } }
        if(rafId) cancelAnimationFrame(rafId); t0=performance.now(); draw(); }
      function star(ctx, r){ ctx.beginPath(); const spikes=5; const outer=r, inner=r*0.5; for(let i=0;i<spikes*2;i++){ const rad=(i*Math.PI)/spikes; const rr= i%2? inner: outer; ctx.lineTo(Math.cos(rad)*rr, Math.sin(rad)*rr);} ctx.closePath(); ctx.fill(); }
      function draw(){ rafId=requestAnimationFrame(draw); const W=confettiCanvas.width, H=confettiCanvas.height; ctx.clearRect(0,0,W,H); ctx.save(); ctx.shadowBlur=8; ctx.shadowColor='rgba(255,255,255,.6)'; for(const p of parts){ p.x+=p.vx; p.y+=p.vy; p.vy+=p.g; p.r+=p.rot; p.a*=0.996; ctx.globalAlpha = Math.max(0,Math.min(1,p.a)); ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.r); if(p.shape==='rect'){ ctx.fillRect(-p.s,-p.s,p.s*2,p.s*2);} else if(p.shape==='circle'){ ctx.beginPath(); ctx.arc(0,0,p.s,0,Math.PI*2); ctx.fill(); } else { star(ctx,p.s*1.4); } ctx.restore(); } ctx.restore(); if(performance.now()-t0>3800){ cancelAnimationFrame(rafId); rafId=null; ctx.clearRect(0,0,W,H);} }
      return { launch };
    })();

    // ===== 恐怖血雾/血滴效果 =====
    const bloodFX = (()=>{ const {ctx} = setupCanvas(fxCanvas); let drops=[], raf=null, t0=0; function burst(){ const W=fxCanvas.width, H=fxCanvas.height; drops=[]; const N=60; for(let i=0;i<N;i++){ drops.push({ x: (W/(window.devicePixelRatio||1))/2 + (Math.random()-0.5)*80, y: (H/(window.devicePixelRatio||1))*0.35 + (Math.random()-0.5)*40, vx:(Math.random()-0.5)*1.2, vy: -Math.random()*2, g: 0.18+Math.random()*0.1, r: 1.5+Math.random()*3, a: .9 }); }
        if(raf) cancelAnimationFrame(raf); t0=performance.now(); draw(); }
      function draw(){ raf=requestAnimationFrame(draw); const W=fxCanvas.width, H=fxCanvas.height; ctx.clearRect(0,0,W,H); for(const d of drops){ d.x+=d.vx; d.y+=d.vy; d.vy+=d.g; d.a*=0.992; ctx.globalAlpha=Math.max(0,d.a); ctx.fillStyle='rgba(200,0,20,1)'; ctx.beginPath(); ctx.arc(d.x,d.y,d.r,0,Math.PI*2); ctx.fill(); }
        // 血雾
        const life = performance.now()-t0; ctx.globalAlpha = Math.max(0, 1 - life/1500); const grd = ctx.createRadialGradient(W*0.5,H*0.3,10, W*0.5,H*0.35, Math.max(W,H)*0.6); grd.addColorStop(0,'rgba(120,0,20,.25)'); grd.addColorStop(1,'rgba(120,0,20,0)'); ctx.fillStyle=grd; ctx.fillRect(0,0,W,H);
        if(life>2500){ cancelAnimationFrame(raf); raf=null; ctx.clearRect(0,0,W,H); }
      }
      return { burst };
    })();

    // ===== 双重确认（恐怖风） =====
    function confirmTwice(thenDo, resumeScene){
      document.body.classList.add('horror-mode');
      setFullFX(true);
      playHorrorFX();
      const box1 = document.createElement('div'); box1.className = 'panel confirm-box';
      const t1 = document.createElement('div'); t1.className='ending glitch confirm-title'; t1.dataset.text='你是否确定这个选择？'; t1.textContent='你是否确定这个选择？';
      const s1 = document.createElement('div'); s1.className='confirm-sub'; s1.textContent='谨慎：这是一次性试炼，返回可重想，继续将进入最终确认。';
      const row1 = document.createElement('div'); row1.className='choices';
      const yes1 = btn('继续','danger', ()=>{
        playHorrorFX();
        const box2 = document.createElement('div'); box2.className='panel confirm-box';
        const t2 = document.createElement('div'); t2.className='ending glitch confirm-title'; t2.dataset.text='最后确认：不可撤回！'; t2.textContent='最后确认：不可撤回！';
        const s2 = document.createElement('div'); s2.className='confirm-sub'; s2.textContent='再次确认后将锁定答案并执行后续流程。';
        const row2 = document.createElement('div'); row2.className='choices';
        const yes2 = btn('我确定','danger', ()=>{ interlude(()=>{ document.body.classList.remove('horror-mode'); thenDo(); }, '锁定选择…'); });
        const no2 = btn('再想想','outline', ()=>{ document.body.classList.remove('horror-mode'); setFullFX(false); resumeScene(); });
        row2.append(yes2, no2); box2.append(t2, s2, row2); mount(box2);
      });
      const no1 = btn('再想想','outline', ()=>{ document.body.classList.remove('horror-mode'); setFullFX(false); resumeScene(); });
      row1.append(yes1, no1); box1.append(t1, s1, row1); mount(box1);
    }, '锁定选择…'); }); const no2 = btn('再想想','outline', ()=>{ document.body.classList.remove('horror-mode'); resumeScene(); }); row2.append(yes2, no2); box2.append(t2, s2, row2); mount(box2); }); const no1 = btn('再想想','outline', ()=>{ document.body.classList.remove('horror-mode'); resumeScene(); }); row1.append(yes1, no1); box1.append(t1, s1, row1); mount(box1); }

    function sceneEndHorror(text, sub, pts=0, stage=1){
      setFullFX(true);
      document.body.classList.add('horror-mode');
      const box = mk('div', {className:'panel'});
      const big = mk('div', {className:'ending glitch no-select'});
      big.dataset.text = text; big.textContent = text; box.append(big);
      if(sub) box.append(mk('div', {className:'subtitle no-select'}, sub));
      const sc = mk('div', {className:'score'}, `失败得分：${pts} 分`); box.append(sc);
      const q = mk('p', {className:'subtitle'}, pick(failureQuotes[stage]||['…'])); box.append(q);
      mount(box);
      // 全屏恐怖特效
      playHorrorFX();
      bloodFX.burst();
    }); const big = mk('div', {className:'ending glitch no-select'}); big.dataset.text = text; big.textContent = text; box.append(big); if(sub) box.append(mk('div', {className:'subtitle no-select'}, sub)); const sc = mk('div', {className:'score'}, `失败得分：${pts} 分`); box.append(sc); const q = mk('p', {className:'subtitle'}, pick(failureQuotes[stage]||['…'])); box.append(q); mount(box); playHorrorFX(); bloodFX.burst(); }

    function sceneFinalWin(){
      setFullFX(true);
      document.body.classList.remove('horror-mode');
      const box=mk('div',{className:'panel'});
      const big=mk('div',{className:'art100 no-select'},'100分！！！好兄弟一辈子！！！');
      box.append(big); mount(box);
      // 全屏礼花 & 提示音
      conf.launch(5);
      playWinFX();
    }); const big=mk('div',{className:'art100 no-select'},'100分！！！好兄弟一辈子！！！'); box.append(big); mount(box); conf.launch(4); playWinFX(); }

    // ===== 场景（题目树） =====
    function sceneStart(){
      // 进入普通模式
      setFullFX(false);
      document.body.classList.remove('horror-mode');
      score=0;
      const box=mk('div',{className:'panel'});
      box.append(btn('确定','ok',()=> interlude(sceneQ1,'启动友情试炼…')));
      mount(box);
    }); box.append(btn('确定','ok',()=> interlude(sceneQ1,'启动友情试炼…'))); mount(box); }

    function sceneQ1(){ document.body.classList.remove('horror-mode'); document.querySelector('.title').textContent='问题 1/5 · 我是你兄弟吗？'; const box=mk('div',{className:'panel'}); box.append(mk('p',{className:'subtitle'},'请选择你的真实想法：')); box.append(choiceButtons([
      {label:'1. 是',type:'ok',onClick:()=> confirmTwice(()=>sceneQ2(), sceneQ1)},
      {label:'2. 否',type:'danger',onClick:()=> confirmTwice(()=>{ score=20; sceneEndHorror('你可以去死了','仪式终止。',score,1); }, sceneQ1)}
    ])); mount(box); }

    function sceneQ2(){ document.body.classList.remove('horror-mode'); document.querySelector('.title').textContent='问题 2/5 · 你女朋友和我一起落水你救谁？'; const box=mk('div',{className:'panel'}); box.append(mk('p',{className:'subtitle'},'友情 or 爱情，二选一。')); box.append(choiceButtons([
      {label:'1. 救我',type:'ok',onClick:()=> confirmTwice(()=>sceneQ3(), sceneQ2)},
      {label:'2. 女朋友',type:'danger',onClick:()=> confirmTwice(()=>{ score=40; sceneEndHorror('我们绝交吧','选择已确认。',score,2); }, sceneQ2)}
    ])); mount(box); }

    function sceneQ3(){ document.body.classList.remove('horror-mode'); document.querySelector('.title').textContent='问题 3/5 · 如果我出现需要24小时照顾的残疾，你愿意照顾我吗？'; const box=mk('div',{className:'panel'}); box.append(mk('p',{className:'subtitle'},'只有你可以照顾我，但需要 24 小时。')); box.append(choiceButtons([
      {label:'1. 愿意',type:'ok',onClick:()=> confirmTwice(()=>sceneQ4(), sceneQ3)},
      {label:'2. 不愿意',type:'danger',onClick:()=> confirmTwice(()=>{ score=60; sceneEndHorror('没关系我不怪你','我们感情不到位罢了。',score,3); }, sceneQ3)}
    ])); mount(box); }

    function sceneQ4(){ document.body.classList.remove('horror-mode'); document.querySelector('.title').textContent='问题 4/5 · 如果我是女的，愿不愿意和我上床？'; const box=mk('div',{className:'panel'}); box.append(mk('p',{className:'subtitle'},'认真思考后再作答。')); box.append(choiceButtons([
      {label:'1. 愿意',type:'ok',onClick:()=> confirmTwice(()=>sceneQ5Gate(), sceneQ4)},
      {label:'2. 不愿意',type:'danger',onClick:()=> confirmTwice(()=>{ score=80; sceneEndHorror('我是不是给你脸了？','仪式终止。',score,4); }, sceneQ4)}
    ])); mount(box); }

    function sceneQ5Gate(){ document.body.classList.remove('horror-mode'); document.querySelector('.title').textContent='最终试炼 · 点击确认开始'; const box=mk('div',{className:'panel'}); const tip=mk('p',{className:'subtitle'},'此步骤将检验我们的友情强度。按下确认进入最终问题。'); const confirm=btn('确认开始','',()=> interlude(sceneQ5,'加载最终密钥…')); box.append(tip,confirm); mount(box); }

    function sceneQ5(){ document.body.classList.remove('horror-mode'); document.querySelector('.title').textContent='最终问题 · 友情是否坚固？'; const box=mk('div',{className:'panel only-btn'}); const ask=mk('p',{className:'subtitle'},'去叫我 10 声 爸爸，有意想不到的惊喜，我们的友谊是否坚固，就看你了。'); const go=btn('我现在就去叫','ok',()=> interlude(sceneFinalWin,'核验完成度 100%…')); box.append(ask,go); mount(box); }

    sceneStart();

    // ===== Minimal Self-tests (do not change app behavior) =====
    ;(function runSelfTests(){
      try {
        console.groupCollapsed('%c[SelfTest] 开始', 'color:#0ff');
        console.assert(typeof window.invoke === 'function', 'invoke shim 存在');
        console.assert(typeof sceneStart === 'function', 'sceneStart 存在');
        console.assert(typeof sceneQ1 === 'function' && typeof sceneQ2 === 'function', '题目场景函数存在');
        // 运行一次起始场景不应抛错
        sceneStart();
        console.log('[SelfTest] 场景渲染 OK');
        console.groupEnd();
      } catch(e){
        console.error('[SelfTest] 失败：', e);
      }
    })();
  </script>
</body>
</html>
